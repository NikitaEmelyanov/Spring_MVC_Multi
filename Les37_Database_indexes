______________________________________________Без индекса__________________________________________

                                   Transaction
-----------------------------------------------------------------------------------
| transaction_id | transaction_date | amount | transaction_type | bank_account_id |
|----------------|------------------|--------|------------------|-----------------|
|       1        |  8/31/2014 0:00  | 100    |  C               | 1               |
|       3        |  8/21/2014 0:00  | 7.1    |  C               | 3               |
|       4        |  8/22/2014 0:00  | 10     |  D               | 1               |
|       5        |  8/23/2014 0:00  | 100    |  D               | 2               |
|       6        |  8/24/2014 0:00  | 99.9   |  D               | 1               |
|       7        |  8/25/2014 0:00  | 112    |  D               | 2               |
|       8        |  8/26/2014 0:00  | 1      |  D               | 3               |
|       9        |  8/29/2014 0:00  | 100    |  D               | 2               |
|       10       |  2/22/2013 0:00  | 1.2    |  D               | 3               |
|       11       |  11/4/2004 0:00  | 100    |  D               | 2               |
|       12       |  5/29/2004 0:00  | 9090   |  D               | 3               |
|       13       |  7/23/2012 0:00  | 160    |  D               | 3               |
|       14       |  11/25/2012 0:00 | 100    |  D               | 3               |
|       15       |  6/15/2012 0:00  | 12     |  D               | 1               |
|       16       |  8/31/2014 0:00  | 100    |  D               | 2               |
                                  ...
                           Еще 5 миллионов строк

SELECT * FROM Transaction WHERE amount > 500
SELECT * FROM Transaction WHERE amount = 99.99         <--- Примеры медленных запросов

1) Значения в колонке amount расположены хаотично (неупорядоченно)
2) Запросы, которые используют это колонку будут заставлять БД проходиться по всем значениям колонки
(англ. full table scan)
3) Необходимо ускорить запросы использующие колонку amount
4) На этой колонке необходимо создать индекс

Индекс это еще одна сущность в БД, это может быть отдельная таблица (В нашем случае столбцами в
таблице будут transaction_id и amount, таким образом значения будут отсортированы.

При линейном поиске нужного элемента в худшем случае нужно будет проверит 5 млн элементов - долго,
займет много ресурсов

Но если отсортировать этот список можно будет воспользоваться двоичным поиском.
Алгоритм двоичного поиска:
1) Смотрим число в центре (mid = low + high - low)/2
2) Оно больше искомого? - рассматриваем левый подмассив
3) Оно меньше искомого? - рассматриваем правый подмассив
4) Оно равняется искомому? - нашли число, возвращаем его индекс
5) Повторяем пока подмассив не станет пустым
Двоичный поиск по 5 млн строк в худшем случае займет lod2(5.000.000) = 23 итерации

___________________________________Недостатки индексов______________________________________________
1) Надо поддерживать индекс в отсортированном виде (при каждой вставке) ---> более медленные
вставки в таблицу
2) Индексы занимают память на диске (5млн строк в таблице ---> 5 млн. строк в индексе)
Поэтому индекс надо создавать только для тех колонок, по которым чаще всего производится поиск
( с помощью WHERE, например)

__________________________________Индексы в PostgreSQL______________________________________________
CREATE INDEX ON Transaction(amount) USING ??? - запрос на создание индекса

1) PRIMARY KEY - первичный ключ индексируется по умолчанию
2) B-Tree Index
3) Hash Index
4) Gin & Gist Index
5) BRIN Index
Все индексы упорядочивают данные тем или иным способом, чтобы ускорить поиск по этим данным